// we need the latest version of bison
%require "3.7.6"

//the evaluated language is c++
%language "c++"

// Use a type-save variant data structure for storing values
%define api.value.type variant

// Generate the various `make_<TOKEN>` functions
%define api.token.constructor

// Include the common interfaces in the generated header
%code requires {
    #include "common.hpp"
}

//we need to declare the method yylex, defined in the
// Declare the `yylex` method, which will be defined in the lexer
%code {
    YY_DECL;
}

%%

%token CLASS_KEYWORD;

%token PUBLIC_KEYWORD;
%token PROTECTED_KEYWORD;
%token PRIVATE_KEYWORD;

%token FINAL_KEYWORD;
%token STATIC_KEYWORD;

%token IF_KEYWORD;
%token WHILE_KEYWORD;
%token RETURN_KEYWORD;

%token  PARANTEZA_DESCHISA;
%token  PARANTEZA_INCHISA;
%token ACOLADA_DESCHISA;
%token ACOLADA_INCHISA;
%token PARANTEZA_PATRATA_DESCHISA;
%token PARANTEZA_PATRATA_INCHISA;
%token EGAL;
%token VIRGULA;
%token PUNCTVIRGULA;
%token PUNCT;
%token PLUS;
%token MINUS;
%token MAI_MIC;
%token MAI_MARE;
%token EGAL_EGAL;
%token MAI_MARE_EGAL;
%token MAI_MIC_EGAL;
%token NOT_EGAL;

// Operator precedence
%left MAI_MIC MAI_MARE;
%left PLUS MINUS;

%token <std::string> IDENTIFIER;
%token <int> NUMBER;
%token <std::string> STRING;

program:
    componente

componente: 
    %empty | componenta componente

componenta:
    class_definition | variable_declaration | function_definition


class_definition:
    access_modifier CLASS_KEYWORD IDENTIFIER
    ACOLADA_DESCHISA class_body ACOLADA_INCHISA
    {
        std::cout << "Definire clasa cu numele:  " << $3 << '\n';
    }

%nterm class_body;
class_body:
    definitions

definitions:
    %empty | definition definitions

definition:
    definire_variabila_clasa | definire_metoda_clasa

definire_variabila_clasa:
    access_modifier   type_identifier name optional_initializer PUNCTVIRGULA
    {
        std::cout << "Definire variabila cu numele:  " << $3 << '\n';
    }

function_definition:
    type_identifier name
    PARANTEZA_DESCHISA method_arguments  PARANTEZA_INCHISA
    ACOLADA_DESCHISA method_body  ACOLADA_INCHISA
    {
        std::cout << "Defining method " << $2 << '\n';
    }
    

definire_metoda_clasa:
    access_modifier   type_identifier name
     PARANTEZA_DESCHISA method_arguments  PARANTEZA_INCHISA
    ACOLADA_DESCHISA method_body ACOLADA_INCHISA
    {
        std::cout << "Defining method " << $3 << '\n';
    }

method_arguments:
    %empty
    | argument
    | argument VIRGULA method_arguments

argument:
    type_identifier IDENTIFIER

method_body:
    statements

statements:
    %empty | statement statements

statement:
    variable_declaration
    | assignment
    | method_call PUNCTVIRGULA
    | instructiune_if
    | instructiune_while
    | return_statement

instructiune_if:
    IF_KEYWORD conditie block
    {
        std::cout << "Definire block if\n";
    }

instructiune_while:
    WHILE_KEYWORD conditie block
    {
        std::cout << "Definire block while\n";
    }

conditie:
     PARANTEZA_DESCHISA expression  PARANTEZA_INCHISA

block:
    ACOLADA_DESCHISA statements ACOLADA_INCHISA

variable_declaration:
    type_identifier name optional_initializer PUNCTVIRGULA
    {
        std::cout << "Defining variable " << $2 << '\n';
    }

assignment:
    name initializer PUNCTVIRGULA
    {
        std::cout << "Assigning to variable " << $1 << '\n';
    }

method_call:
    method_reference
     PARANTEZA_DESCHISA actual_parameters  PARANTEZA_INCHISA
    {
        std::cout << "Calling method " << $1 << '\n';
    }

return_statement:
    RETURN_KEYWORD PUNCTVIRGULA
    | RETURN_KEYWORD expression PUNCTVIRGULA
    {std::cout << "Intalnire cuvant return " << '\n';}

actual_parameters:
    %empty
    | value
    | value VIRGULA actual_parameters

value:
    name | expression

%nterm expression;
expression:
    expression PLUS expression
    | expression MINUS expression
    | expression MAI_MIC expression
    | expression MAI_MARE expression
    | expression EGAL_EGAL expression
    | expression NOT_EGAL expression
    | expression MAI_MARE_EGAL expression
    | expression MAI_MIC_EGAL expression
    | method_call
    | name
    | literal

%nterm <std::string> method_reference;
method_reference:
    name
    { $$ = $1; }
    | name PUNCT method_reference
    { $$ = $1 + "." + $3; }

%nterm <AccessModifier> access_modifier;
access_modifier:
    %empty
    { $$ = AccessModifier::DEFAULT; }
    | PUBLIC_KEYWORD
    { $$ = AccessModifier::PUBLIC; }
    | PROTECTED_KEYWORD
    { $$ = AccessModifier::PROTECTED; }
    | PRIVATE_KEYWORD
    { $$ = AccessModifier::PRIVATE; }




type_identifier:
    IDENTIFIER
    {
        std::cout << "Referencing object type " << $1 << '\n';
    }
    | IDENTIFIER PARANTEZA_PATRATA_DESCHISA PARANTEZA_PATRATA_INCHISA
    {
        std::cout << "Referencing array type " << $1 << "[]" << '\n';
    }

%nterm <std::string> name;
name:
    IDENTIFIER

optional_initializer:
    %empty | initializer

initializer:
    EGAL expression

%nterm <std::string> literal;
literal:
    STRING | NUMBER
    { $$ = std::to_string($1); }

%%

namespace yy
{
    // Report an error to the user.
    void parser::error(const std::string& message)
    {
        std::cerr << message << '\n';
    }
}

int main(int argc, char* argv[])
{
    if (argc > 1)
    {
        freopen(argv[1], "r", stdin);
    }

    yy::parser cplusplus_parser;
    return cplusplus_parser();
}